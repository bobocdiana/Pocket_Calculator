import java.util.Stack;

/** This class has methods to parse the given expression and translate it into its 
 * postfixated form using the postfixat() method.
 * Given the fact that the user will only call the method eval() to calculate the result
 * of the given expression, the method eval() will call the method postfixat() to translate
 * the expression into its postfixated form and after that it will parse the new expression 
 * and calculate its result.
 * 	The class has two visitors which will handle the translation of the given expression and
 * calculating the postfixated expression's result.It also has an AST which contains the 
 * expression's operands and operators.Also, all the operators which can be contained by an
 * expression are saved in the String op and the position of every operantor inside the string
 * also gives us the operator's priority.  
 * 
 */
public class ExpressionParser {
	public static String op = "()+-*/^ -- log sin cos sqrt";
	public AST expression_tree = new AST();
	public Postfixat_Visitor postfixated = new Postfixat_Visitor();
	public Evaluator_Visitor evaluator = new Evaluator_Visitor();
	
	/**This method parses the given expression and returns the postfixated form of it.
	 * The method also implements the Visitor design pattern, so for every "node" of the
	 * AST is applied the accept(Postfixa_Visitor) method in order to be evaluated.
	 * 
	 * @param expression = the given expression as input
	 * @return the postfixated form of expression
	 * @throws SyntacticException if the given expression is syntacticaly wrong
	 */
	public String postfixat(String expression) throws SyntacticException {
		int i;
		expression_tree.parser = expression.split(" ");
		for (i = 0; i < expression_tree.parser.length; i++) {
			expression_tree.current = i;
			expression_tree.accept(postfixated);
		}
		while (expression_tree.operations.isEmpty() == false) {
			if (expression_tree.operations.peek().equals(")")
					|| expression_tree.operations.peek().equals("(")) {
				throw new SyntacticException("incorrect paranthesis");
			} else {
				expression_tree.postfixat
						.push(expression_tree.operations.pop());
			}
		}
		
		/* This is the part where the postfixated expression is formed based on
		 * the AST postfixat stack which contains the postfixated expression. 
		 */
		String after = expression_tree.postfixat.pop();
		String aux;
		while (expression_tree.postfixat.isEmpty() == false) {
			if (expression_tree.postfixat.peek().equals(")")
					|| expression_tree.postfixat.peek().equals("(")) {
				throw new SyntacticException("incorrect paranthesis");
			} else {
				aux = expression_tree.postfixat.pop();
				after = aux.concat(" ").concat(after);
			}
		}
		expression_tree.postfixated_expression = after;
		return expression_tree.postfixated_expression;
	}
	
	/**This method obtains the given expression's postfixated form calling 
	 * the postfixat method and after that it parses the new expression and
	 * calculates its operations.
	 * The method also uses the Visitor design pattern, so for every "node" of
	 * the AST it is called the accept(Evaluator_Visitor) method which calculates
	 * the result of the subtree generated by the "node" as the subtree's root.  
	 * 
	 * @param expression=the given expression as input
	 * @return the result of the given expression
	 * @throws SyntacticException if expression is syntacticaly wrong
	 * @throws EvaluatorException if the expression has to do wrong operations (a.k.a log(0) )
	 */
	public float eval(String expression) throws SyntacticException,
			EvaluatorException {
		String post_expression = postfixat(expression);
		expression_tree.parser = post_expression.split(" ");
		for (int i = 0; i < expression_tree.parser.length; i++) {
			expression_tree.current = i;
			expression_tree.accept(evaluator);
		}
		double result = expression_tree.operators.pop();
		if (expression_tree.operators.isEmpty() == false) {
			throw new SyntacticException("wrong expression");
		}

		return (float) result;
	}

}
